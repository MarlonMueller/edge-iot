<html>
<head>
    <title>PCM Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href='http://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <link rel="icon" href="image/favicon.ico" type="image/x-icon">
    <script src="https://cdn.plot.ly/plotly-latest.min.js" charset="utf-8"></script>
    <script src="https://unpkg.com/pcm-player"></script>
    <script type="js/worker.js"></script>

    
</head>
<style>
    h1{ 
        text-align: center;
    }
    html,body {
        font-family: 'Roboto', sans-serif;
        background-color: darkslategrey !important; 
        margin: 0;
        padding: 20px 15px;
    }

    .button {
        background-color: cyan;
        border: none;
        border-radius: 12px;
        padding: 15px 32px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-size: 16px;
        margin: 4px 2px;
        cursor: pointer;
    }
</style>
<body>
    <h1>Bird Watcher live audio</h1>
    <button style="background-color: goldenrod;"  id="connectBtn" class="button" onclick="connect()">Connect to websocket</button>
    <input type="range" max="1" value="0.1" min="0" id="range" onchange="changeVolume(event)" step="0.1"><br />
    <button id="pauseBtn" class="button" onclick="pause()">Pause Playing</button>
    <button id="continueBtn" class="button" onclick="continuePlay()">Continue Playing</button>
    <button style="margin-bottom:10px; background-color: goldenrod;" id="downloadBtn" class="button" onclick="downloadAudio()">Download Audio</button>
    <div id="graph"></div>
    <script>
    // import audioBufferToWav from 'audiobuffer-to-wav';


    var connectBtn = document.getElementById("connectBtn");
    var pauseBtn = document.getElementById("pauseBtn");
    var continueBtn = document.getElementById("continueBtn");
    connectBtn.disabled = false;
    pauseBtn.disabled = true;
    continueBtn.disabled = true;

    var worker = new Worker('js/worker.js')
    
    var audioDataArray = [];

    worker.addEventListener('message', function (e) {
        var mean = e.data;
        var byteArray = e.data.byteArray;
       
        graphDataArray = graphDataArray.concat(mean);
        graphDataArray.splice(0, 1);

        var data_update = {
            y: [graphDataArray]
        };

        Plotly.update('graph', data_update);
    }, false);
    const arrayLength = 100
    var graphDataArray = []

    for (var i = 0; i < arrayLength; i++) {
        graphDataArray[i] = 0;
    }

    var layout = {
        title: 'Streaming Data',
        paper_bgcolor: "#000",
        plot_bgcolor: "#000",
            xaxis: {
                domain: [0, 1],
                showticklabels: false,
                color: "#FFF",
            },
            yaxis: { domain: [0, 1],
            color: "#FFF",
            rangemode: "auto",
            },
        }

    Plotly.newPlot('graph', [{
        y: graphDataArray,
        mode: 'lines',
        line: { color: '#DF56F1' }
    }], layout);

    let player;
    window.connect = function connect() {

        connectBtn.disabled = !connectBtn.disabled;
        pauseBtn.disabled = !pauseBtn.disabled;

        player = new PCMPlayer({
            inputCodec: 'Int16',
            channels: 1,
            sampleRate: 16000,
            // sampleRate: 44100,
        });
        const WS_URL = 'ws:///172.20.10.2:8888'
        var ws = new WebSocket(WS_URL)
        ws.binaryType = 'arraybuffer'
        ws.addEventListener('message', function (event) {
            if(continueBtn.disabled){

                // Assuming audioDataArray is defined somewhere outside this scope
// Initialize audioDataArray if not already done
if (!audioDataArray) {
    audioDataArray = new Int16Array([]);
}

// Concatenate the new data to the existing array
var byteArray = new Int16Array(event.data);
audioDataArray = new Int16Array([...audioDataArray.slice(-48000), ...byteArray]);

// console.log(audioDataArray);

                player.feed(event.data)
                worker.postMessage(event.data) // Remove if it makes the web browser slow.
            }
        });
    }
    window.changeVolume = function changeVolume(e) {
        player.volume(document.querySelector('#range').value)
    }
    window.pause = async function pause() {
        pauseBtn.disabled = true;
        continueBtn.disabled = false;
        await player.pause()
    }
    window.continuePlay = function continuePlay() {
        player.continue()
        pauseBtn.disabled = false;
        continueBtn.disabled = true;
    }

    // AUDIO DOWNLOAD
        function audioBufferToWav (buffer, opt) {
        opt = opt || {}

        var numChannels = buffer.numberOfChannels
        var sampleRate = buffer.sampleRate
        var format = opt.float32 ? 3 : 1
        var bitDepth = format === 3 ? 32 : 16

        var result
        if (numChannels === 2) {
            result = interleave(buffer.getChannelData(0), buffer.getChannelData(1))
        } else {
            result = buffer.getChannelData(0)
        }

        return encodeWAV(result, format, sampleRate, numChannels, bitDepth)
        }

        function encodeWAV (samples, format, sampleRate, numChannels, bitDepth) {
        var bytesPerSample = bitDepth / 8
        var blockAlign = numChannels * bytesPerSample

        var buffer = new ArrayBuffer(44 + samples.length * bytesPerSample)
        var view = new DataView(buffer)

        /* RIFF identifier */
        writeString(view, 0, 'RIFF')
        /* RIFF chunk length */
        view.setUint32(4, 36 + samples.length * bytesPerSample, true)
        /* RIFF type */
        writeString(view, 8, 'WAVE')
        /* format chunk identifier */
        writeString(view, 12, 'fmt ')
        /* format chunk length */
        view.setUint32(16, 16, true)
        /* sample format (raw) */
        view.setUint16(20, format, true)
        /* channel count */
        view.setUint16(22, numChannels, true)
        /* sample rate */
        view.setUint32(24, sampleRate, true)
        /* byte rate (sample rate * block align) */
        view.setUint32(28, sampleRate * blockAlign, true)
        /* block align (channel count * bytes per sample) */
        view.setUint16(32, blockAlign, true)
        /* bits per sample */
        view.setUint16(34, bitDepth, true)
        /* data chunk identifier */
        writeString(view, 36, 'data')
        /* data chunk length */
        view.setUint32(40, samples.length * bytesPerSample, true)
        if (format === 1) { // Raw PCM
            floatTo16BitPCM(view, 44, samples)
        } else {
            writeFloat32(view, 44, samples)
        }

        return buffer
        }

        function interleave (inputL, inputR) {
        var length = inputL.length + inputR.length
        var result = new Float32Array(length)

        var index = 0
        var inputIndex = 0

        while (index < length) {
            result[index++] = inputL[inputIndex]
            result[index++] = inputR[inputIndex]
            inputIndex++
        }
        return result
        }

        function writeFloat32 (output, offset, input) {
        for (var i = 0; i < input.length; i++, offset += 4) {
            output.setFloat32(offset, input[i], true)
        }
        }

        function floatTo16BitPCM (output, offset, input) {
        for (var i = 0; i < input.length; i++, offset += 2) {
            var s = Math.max(-1, Math.min(1, input[i]))
            output.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true)
        }
        }

        function writeString (view, offset, string) {
        for (var i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i))
        }
        }
        window.downloadAudio = function downloadAudio() {
            if (audioDataArray.length === 0) {
                alert('No audio data available for download.');
                return;
            }
            
            var audioBuffer = new AudioBuffer({
            length: audioDataArray.length,  
            numberOfChannels: 1,            // mono audio
            sampleRate: 16000               // sample rate
            });

            // Fill the audio buffer our data
            audioBuffer.getChannelData(0).set(audioDataArray);

            var wav = audioBufferToWav(audioBuffer);
            var blob = new window.Blob([ new DataView(wav) ], {
            type: 'audio/wav'
            })


            var audioUrl = URL.createObjectURL(blob);

            var a = document.createElement('a');
            a.href = audioUrl;
            a.download = 'audio.wav';
            a.click();
        };
</script>
</body>
</html>